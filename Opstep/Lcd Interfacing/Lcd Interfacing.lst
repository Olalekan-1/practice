CCS PCM C Compiler, Version 5.015, 5967               08-May-25 17:45

               Filename:   C:\Users\Ahmed Olalekan\Desktop\practice\Opstep\Lcd Interfacing\Lcd Interfacing.lst

               ROM used:   491 words (48%)
                           Largest free fragment is 533
               RAM used:   6 (9%) at main() level
                           41 (60%) worst case
               Stack used: 4 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   15E
0003:  NOP
.................... #include <Lcd Interfacing.h> 
.................... #include <16F84A.h> 
.................... //////////// Standard Header file for the PIC16F84A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F84A 
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0161:  CLRF   10
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0151:  MOVF   29,W
0152:  MOVWF  2A
0153:  MOVF   2A,W
0154:  MOVWF  04
0155:  MOVF   00,F
0156:  BTFSC  03.2
0157:  GOTO   15A
0158:  INCF   2A,F
0159:  GOTO   153
....................    return(sc - s); 
015A:  MOVF   29,W
015B:  SUBWF  2A,W
015C:  MOVWF  0D
015D:  GOTO   1CB (RETURN)
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES XT,NOWDT,PUT,PROTECT 
.................... #use delay(crystal=4000000) 
*
0004:  MOVLW  2E
0005:  MOVWF  04
0006:  MOVF   00,W
0007:  BTFSC  03.2
0008:  GOTO   017
0009:  MOVLW  01
000A:  MOVWF  0D
000B:  CLRF   0C
000C:  DECFSZ 0C,F
000D:  GOTO   00C
000E:  DECFSZ 0D,F
000F:  GOTO   00B
0010:  MOVLW  4A
0011:  MOVWF  0C
0012:  DECFSZ 0C,F
0013:  GOTO   012
0014:  GOTO   015
0015:  DECFSZ 00,F
0016:  GOTO   009
0017:  RETURN
....................  
.................... #define LCD_DATA_PORT getenv("SFR:PORTb") 
.................... #define LCD_ENABLE_PIN  PIN_b3                                    //// 
.................... #define LCD_RS_PIN      PIN_b1                                    //// 
.................... #define LCD_RW_PIN      PIN_b2                                    //// 
.................... #define LCD_DATA4       PIN_b4                                    //// 
.................... #define LCD_DATA5       PIN_b5                                    //// 
.................... #define LCD_DATA6       PIN_b6                                    //// 
.................... #define LCD_DATA7       PIN_b7                                    //// 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
007C:  BSF    06.4
....................    output_float(LCD_DATA5); 
007D:  BSF    06.5
....................    output_float(LCD_DATA6); 
007E:  BSF    06.6
....................    output_float(LCD_DATA7); 
007F:  BSF    06.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0080:  BCF    03.5
0081:  BSF    06.2
0082:  BSF    03.5
0083:  BCF    06.2
....................    delay_cycles(1); 
0084:  NOP
....................    lcd_output_enable(1); 
0085:  BCF    03.5
0086:  BSF    06.3
0087:  BSF    03.5
0088:  BCF    06.3
....................    delay_cycles(1); 
0089:  NOP
....................    high = lcd_read_nibble(); 
008A:  BCF    03.5
008B:  CALL   043
008C:  MOVF   0D,W
008D:  MOVWF  32
....................        
....................    lcd_output_enable(0); 
008E:  BCF    06.3
008F:  BSF    03.5
0090:  BCF    06.3
....................    delay_cycles(1); 
0091:  NOP
....................    lcd_output_enable(1); 
0092:  BCF    03.5
0093:  BSF    06.3
0094:  BSF    03.5
0095:  BCF    06.3
....................    delay_us(1); 
0096:  NOP
....................    low = lcd_read_nibble(); 
0097:  BCF    03.5
0098:  CALL   043
0099:  MOVF   0D,W
009A:  MOVWF  31
....................        
....................    lcd_output_enable(0); 
009B:  BCF    06.3
009C:  BSF    03.5
009D:  BCF    06.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
009E:  BCF    06.4
....................    output_drive(LCD_DATA5); 
009F:  BCF    06.5
....................    output_drive(LCD_DATA6); 
00A0:  BCF    06.6
....................    output_drive(LCD_DATA7); 
00A1:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00A2:  BCF    03.5
00A3:  SWAPF  32,W
00A4:  MOVWF  0C
00A5:  MOVLW  F0
00A6:  ANDWF  0C,F
00A7:  MOVF   0C,W
00A8:  IORWF  31,W
00A9:  MOVWF  0D
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0043:  CLRF   33
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0044:  BSF    03.5
0045:  BSF    06.4
0046:  MOVLW  00
0047:  BCF    03.5
0048:  BTFSC  06.4
0049:  MOVLW  01
004A:  IORWF  33,F
....................    n |= input(LCD_DATA5) << 1; 
004B:  BSF    03.5
004C:  BSF    06.5
004D:  MOVLW  00
004E:  BCF    03.5
004F:  BTFSC  06.5
0050:  MOVLW  01
0051:  MOVWF  0C
0052:  BCF    03.0
0053:  RLF    0C,F
0054:  MOVF   0C,W
0055:  IORWF  33,F
....................    n |= input(LCD_DATA6) << 2; 
0056:  BSF    03.5
0057:  BSF    06.6
0058:  MOVLW  00
0059:  BCF    03.5
005A:  BTFSC  06.6
005B:  MOVLW  01
005C:  MOVWF  0C
005D:  RLF    0C,F
005E:  RLF    0C,F
005F:  MOVLW  FC
0060:  ANDWF  0C,F
0061:  MOVF   0C,W
0062:  IORWF  33,F
....................    n |= input(LCD_DATA7) << 3; 
0063:  BSF    03.5
0064:  BSF    06.7
0065:  MOVLW  00
0066:  BCF    03.5
0067:  BTFSC  06.7
0068:  MOVLW  01
0069:  MOVWF  0C
006A:  RLF    0C,F
006B:  RLF    0C,F
006C:  RLF    0C,F
006D:  MOVLW  F8
006E:  ANDWF  0C,F
006F:  MOVF   0C,W
0070:  IORWF  33,F
....................     
....................    return(n); 
0071:  MOVF   33,W
0072:  MOVWF  0D
....................   #else 
0073:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0018:  BTFSC  32.0
0019:  GOTO   01C
001A:  BCF    06.4
001B:  GOTO   01D
001C:  BSF    06.4
001D:  BSF    03.5
001E:  BCF    06.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
001F:  BCF    03.5
0020:  BTFSC  32.1
0021:  GOTO   024
0022:  BCF    06.5
0023:  GOTO   025
0024:  BSF    06.5
0025:  BSF    03.5
0026:  BCF    06.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0027:  BCF    03.5
0028:  BTFSC  32.2
0029:  GOTO   02C
002A:  BCF    06.6
002B:  GOTO   02D
002C:  BSF    06.6
002D:  BSF    03.5
002E:  BCF    06.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
002F:  BCF    03.5
0030:  BTFSC  32.3
0031:  GOTO   034
0032:  BCF    06.7
0033:  GOTO   035
0034:  BSF    06.7
0035:  BSF    03.5
0036:  BCF    06.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0037:  NOP
....................    lcd_output_enable(1); 
0038:  BCF    03.5
0039:  BSF    06.3
003A:  BSF    03.5
003B:  BCF    06.3
....................    delay_us(2); 
003C:  GOTO   03D
....................    lcd_output_enable(0); 
003D:  BCF    03.5
003E:  BCF    06.3
003F:  BSF    03.5
0040:  BCF    06.3
0041:  BCF    03.5
0042:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0074:  BSF    03.5
0075:  BCF    06.3
....................    lcd_rs_tris(); 
0076:  BCF    06.1
....................    lcd_rw_tris(); 
0077:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0078:  BCF    03.5
0079:  BCF    06.1
007A:  BSF    03.5
007B:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00AA:  MOVF   0D,W
00AB:  MOVWF  31
00AC:  BTFSS  31.7
00AD:  GOTO   0B0
00AE:  BSF    03.5
00AF:  GOTO   07C
....................    lcd_output_rs(address); 
00B0:  MOVF   2F,F
00B1:  BTFSS  03.2
00B2:  GOTO   0B5
00B3:  BCF    06.1
00B4:  GOTO   0B6
00B5:  BSF    06.1
00B6:  BSF    03.5
00B7:  BCF    06.1
....................    delay_cycles(1); 
00B8:  NOP
....................    lcd_output_rw(0); 
00B9:  BCF    03.5
00BA:  BCF    06.2
00BB:  BSF    03.5
00BC:  BCF    06.2
....................    delay_cycles(1); 
00BD:  NOP
....................    lcd_output_enable(0); 
00BE:  BCF    03.5
00BF:  BCF    06.3
00C0:  BSF    03.5
00C1:  BCF    06.3
....................    lcd_send_nibble(n >> 4); 
00C2:  BCF    03.5
00C3:  SWAPF  30,W
00C4:  MOVWF  31
00C5:  MOVLW  0F
00C6:  ANDWF  31,F
00C7:  MOVF   31,W
00C8:  MOVWF  32
00C9:  CALL   018
....................    lcd_send_nibble(n & 0xf); 
00CA:  MOVF   30,W
00CB:  ANDLW  0F
00CC:  MOVWF  31
00CD:  MOVWF  32
00CE:  CALL   018
00CF:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00D0:  MOVLW  28
00D1:  MOVWF  2A
00D2:  MOVLW  0C
00D3:  MOVWF  2B
00D4:  MOVLW  01
00D5:  MOVWF  2C
00D6:  MOVLW  06
00D7:  MOVWF  2D
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00D8:  BCF    06.3
00D9:  BSF    03.5
00DA:  BCF    06.3
....................    lcd_output_rs(0); 
00DB:  BCF    03.5
00DC:  BCF    06.1
00DD:  BSF    03.5
00DE:  BCF    06.1
....................    lcd_output_rw(0); 
00DF:  BCF    03.5
00E0:  BCF    06.2
00E1:  BSF    03.5
00E2:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00E3:  BCF    06.4
....................    output_drive(LCD_DATA5); 
00E4:  BCF    06.5
....................    output_drive(LCD_DATA6); 
00E5:  BCF    06.6
....................    output_drive(LCD_DATA7); 
00E6:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00E7:  BCF    06.3
....................    lcd_rs_tris(); 
00E8:  BCF    06.1
....................    lcd_rw_tris(); 
00E9:  BCF    06.2
....................  #endif 
....................      
....................    delay_ms(15); 
00EA:  MOVLW  0F
00EB:  BCF    03.5
00EC:  MOVWF  2E
00ED:  CALL   004
....................    for(i=1;i<=3;++i) 
00EE:  MOVLW  01
00EF:  MOVWF  29
00F0:  MOVF   29,W
00F1:  SUBLW  03
00F2:  BTFSS  03.0
00F3:  GOTO   0FC
....................    { 
....................        lcd_send_nibble(3); 
00F4:  MOVLW  03
00F5:  MOVWF  32
00F6:  CALL   018
....................        delay_ms(5); 
00F7:  MOVLW  05
00F8:  MOVWF  2E
00F9:  CALL   004
00FA:  INCF   29,F
00FB:  GOTO   0F0
....................    } 
....................     
....................    lcd_send_nibble(2); 
00FC:  MOVLW  02
00FD:  MOVWF  32
00FE:  CALL   018
....................    delay_ms(5); 
00FF:  MOVLW  05
0100:  MOVWF  2E
0101:  CALL   004
....................    for(i=0;i<=3;++i) 
0102:  CLRF   29
0103:  MOVF   29,W
0104:  SUBLW  03
0105:  BTFSS  03.0
0106:  GOTO   112
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0107:  MOVLW  2A
0108:  ADDWF  29,W
0109:  MOVWF  04
010A:  MOVF   00,W
010B:  MOVWF  2E
010C:  CLRF   2F
010D:  MOVF   2E,W
010E:  MOVWF  30
010F:  CALL   074
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0110:  INCF   29,F
0111:  GOTO   103
0112:  GOTO   177 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0113:  DECFSZ 2C,W
0114:  GOTO   116
0115:  GOTO   119
....................       address=LCD_LINE_TWO; 
0116:  MOVLW  40
0117:  MOVWF  2D
0118:  GOTO   11A
....................    else 
....................       address=0; 
0119:  CLRF   2D
....................       
....................    address+=x-1; 
011A:  MOVLW  01
011B:  SUBWF  2B,W
011C:  ADDWF  2D,F
....................    lcd_send_byte(0,0x80|address); 
011D:  MOVF   2D,W
011E:  IORLW  80
011F:  MOVWF  2E
0120:  CLRF   2F
0121:  MOVF   2E,W
0122:  MOVWF  30
0123:  CALL   074
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0124:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0125:  MOVF   2A,W
0126:  XORLW  07
0127:  BTFSC  03.2
0128:  GOTO   133
0129:  XORLW  0B
012A:  BTFSC  03.2
012B:  GOTO   138
012C:  XORLW  06
012D:  BTFSC  03.2
012E:  GOTO   140
012F:  XORLW  02
0130:  BTFSC  03.2
0131:  GOTO   146
0132:  GOTO   14B
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0133:  MOVLW  01
0134:  MOVWF  2B
0135:  MOVWF  2C
0136:  CALL   113
0137:  GOTO   150
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0138:  CLRF   2F
0139:  MOVLW  01
013A:  MOVWF  30
013B:  CALL   074
....................                      delay_ms(2); 
013C:  MOVLW  02
013D:  MOVWF  2E
013E:  CALL   004
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
013F:  GOTO   150
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0140:  MOVLW  01
0141:  MOVWF  2B
0142:  MOVLW  02
0143:  MOVWF  2C
0144:  CALL   113
0145:  GOTO   150
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0146:  CLRF   2F
0147:  MOVLW  10
0148:  MOVWF  30
0149:  CALL   074
014A:  GOTO   150
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
014B:  MOVLW  01
014C:  MOVWF  2F
014D:  MOVF   2A,W
014E:  MOVWF  30
014F:  CALL   074
....................      #endif 
....................    } 
0150:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... void main(){ 
*
015E:  MOVF   03,W
015F:  ANDLW  1F
0160:  MOVWF  03
....................    output_a(0); 
*
0162:  BSF    03.5
0163:  CLRF   05
0164:  BCF    03.5
0165:  CLRF   05
....................    output_b(0); 
0166:  BSF    03.5
0167:  CLRF   06
0168:  BCF    03.5
0169:  CLRF   06
....................    set_tris_a(0b11111); 
016A:  MOVLW  1F
016B:  BSF    03.5
016C:  MOVWF  05
....................    set_tris_b(0b10000000); 
016D:  MOVLW  80
016E:  MOVWF  06
....................    output_a(0); 
016F:  CLRF   05
0170:  BCF    03.5
0171:  CLRF   05
....................    output_b(0); 
0172:  BSF    03.5
0173:  CLRF   06
0174:  BCF    03.5
0175:  CLRF   06
....................     
....................    lcd_init(); 
0176:  GOTO   0D0
....................    lcd_putc('\f'); 
0177:  MOVLW  0C
0178:  MOVWF  2A
0179:  CALL   125
....................    char welcome[8] = "Welcome"; 
017A:  MOVLW  57
017B:  MOVWF  11
017C:  MOVLW  65
017D:  MOVWF  12
017E:  MOVLW  6C
017F:  MOVWF  13
0180:  MOVLW  63
0181:  MOVWF  14
0182:  MOVLW  6F
0183:  MOVWF  15
0184:  MOVLW  6D
0185:  MOVWF  16
0186:  MOVLW  65
0187:  MOVWF  17
0188:  CLRF   18
....................    char name[15] = "Ahmed Olalekan"; 
0189:  MOVLW  41
018A:  MOVWF  19
018B:  MOVLW  68
018C:  MOVWF  1A
018D:  MOVLW  6D
018E:  MOVWF  1B
018F:  MOVLW  65
0190:  MOVWF  1C
0191:  MOVLW  64
0192:  MOVWF  1D
0193:  MOVLW  20
0194:  MOVWF  1E
0195:  MOVLW  4F
0196:  MOVWF  1F
0197:  MOVLW  6C
0198:  MOVWF  20
0199:  MOVLW  61
019A:  MOVWF  21
019B:  MOVLW  6C
019C:  MOVWF  22
019D:  MOVLW  65
019E:  MOVWF  23
019F:  MOVLW  6B
01A0:  MOVWF  24
01A1:  MOVLW  61
01A2:  MOVWF  25
01A3:  MOVLW  6E
01A4:  MOVWF  26
01A5:  CLRF   27
....................    unsigned int8 a; 
....................     
....................    
....................  
....................    while(TRUE){ 
....................       lcd_gotoxy(1,1); 
01A6:  MOVLW  01
01A7:  MOVWF  2B
01A8:  MOVWF  2C
01A9:  CALL   113
....................       for(a = 0; a < sizeof(welcome); a++){ 
01AA:  CLRF   28
01AB:  MOVF   28,W
01AC:  SUBLW  07
01AD:  BTFSS  03.0
01AE:  GOTO   1BF
....................          lcd_putc(welcome[a]); 
01AF:  MOVLW  11
01B0:  ADDWF  28,W
01B1:  MOVWF  04
01B2:  MOVF   00,W
01B3:  MOVWF  29
01B4:  MOVWF  2A
01B5:  CALL   125
....................          delay_ms(1000);    
01B6:  MOVLW  04
01B7:  MOVWF  29
01B8:  MOVLW  FA
01B9:  MOVWF  2E
01BA:  CALL   004
01BB:  DECFSZ 29,F
01BC:  GOTO   1B8
01BD:  INCF   28,F
01BE:  GOTO   1AB
....................       } 
....................       lcd_putc('\f'); 
01BF:  MOVLW  0C
01C0:  MOVWF  2A
01C1:  CALL   125
....................       lcd_gotoxy(1,2); 
01C2:  MOVLW  01
01C3:  MOVWF  2B
01C4:  MOVLW  02
01C5:  MOVWF  2C
01C6:  CALL   113
....................       for(a = 0; a < strlen(name); a++){ 
01C7:  CLRF   28
01C8:  MOVLW  19
01C9:  MOVWF  29
01CA:  GOTO   151
01CB:  MOVF   0D,W
01CC:  SUBWF  28,W
01CD:  BTFSC  03.0
01CE:  GOTO   1DF
....................          lcd_putc(name[a]); 
01CF:  MOVLW  19
01D0:  ADDWF  28,W
01D1:  MOVWF  04
01D2:  MOVF   00,W
01D3:  MOVWF  29
01D4:  MOVWF  2A
01D5:  CALL   125
....................         // printf(lcd_putc "%s", name); 
....................          delay_ms(900); 
01D6:  MOVLW  04
01D7:  MOVWF  29
01D8:  MOVLW  E1
01D9:  MOVWF  2E
01DA:  CALL   004
01DB:  DECFSZ 29,F
01DC:  GOTO   1D8
01DD:  INCF   28,F
01DE:  GOTO   1C8
....................       } 
....................       lcd_putc('\f'); 
01DF:  MOVLW  0C
01E0:  MOVWF  2A
01E1:  CALL   125
....................       // printf("welcome"); 
....................       delay_ms(3000); 
01E2:  MOVLW  0C
01E3:  MOVWF  29
01E4:  MOVLW  FA
01E5:  MOVWF  2E
01E6:  CALL   004
01E7:  DECFSZ 29,F
01E8:  GOTO   1E4
01E9:  GOTO   1A6
....................    } 
....................  
.................... } 
01EA:  SLEEP

Configuration Fuses:
   Word  1: 0001   XT NOWDT PUT PROTECT
